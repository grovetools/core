{
  "usage_patterns": [
    {
      "name": "1. Defining Custom Configuration Extensions",
      "description": "The `grove.yml` configuration system is extensible, allowing tools to define their own top-level configuration blocks without modifying `grove-core`. This is achieved through the `Extensions` field in the `config.Config` struct.\n\nThis pattern is useful when you are building a tool that needs its own specific settings but should integrate with the existing Grove configuration ecosystem.\n\n**Step 1: Define a custom section in `grove.yml`**\n\nAdd a top-level key that is unique to your tool. In this example, we'll add a `flow` block for a hypothetical `grove-flow` tool.\n\n\n**Step 2: Create a Go struct to hold the configuration**\n\nIn your tool's Go code, define a struct that maps to the YAML structure of your custom section. Use `yaml` tags to specify the field names.\n\n\n**Step 3: Load the configuration and unmarshal the extension**\n\nUse `config.LoadDefault()` to load the entire `grove.yml` file, and then use the `UnmarshalExtension` method to parse your custom section into your struct.",
      "example": "# grove.yml\nversion: \"1.0\"\n\nservices:\n  api:\n    image: node:18\n\n# Custom section for our tool\nflow:\n  chat_directory: \"/path/to/chats\"\n  max_messages: 100\n  default_model: \"claude-3-opus\"\npackage main\n\n// FlowConfig defines the structure for the 'flow' section in grove.yml\ntype FlowConfig struct {\n    ChatDirectory string `yaml:\"chat_directory\"`\n    MaxMessages   int    `yaml:\"max_messages\"`\n    DefaultModel  string `yaml:\"default_model\"`\n}\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/mattsolo1/grove-core/config\"\n)\n\nfunc main() {\n    // Load the complete grove.yml configuration\n    coreCfg, err := config.LoadDefault()\n    if err != nil {\n        log.Fatalf(\"Failed to load configuration: %v\", err)\n    }\n\n    // Create an instance of our custom config struct\n    var flowCfg FlowConfig\n\n    // Unmarshal the 'flow' extension into our struct\n    if err := coreCfg.UnmarshalExtension(\"flow\", \u0026flowCfg); err != nil {\n        log.Fatalf(\"Failed to parse 'flow' configuration: %v\", err)\n    }\n\n    // Now you can use the type-safe configuration\n    fmt.Printf(\"Chat directory: %s\\n\", flowCfg.ChatDirectory)\n    fmt.Printf(\"Default model: %s\\n\", flowCfg.DefaultModel)\n}"
    },
    {
      "name": "2. Hierarchical Configuration Merging",
      "description": "`grove-core` loads configuration from up to three different files, merging them to produce a final, consolidated configuration. This allows for a flexible setup with global defaults, project-specific settings, and local developer overrides.\n\nThe merge order is:\n1.  **Global**: `~/.config/grove/grove.yml` (lowest precedence)\n2.  **Project**: `grove.yml` in the project directory\n3.  **Override**: `grove.override.yml` in the project directory (highest precedence)\n\n**Example Scenario:**\n\nImagine you want a global default setting, a project-specific service definition, and a local override for a service port.\n\n**File 1: Global Configuration (`~/.config/grove/grove.yml`)**\n\nThis file sets a global default for all projects, such as the port for the Master Control Program (MCP).\n\n\n**File 2: Project Configuration (`./grove.yml`)**\n\nThis is the main configuration file for the project, checked into version control. It defines the project's services and overrides the global network name.\n\n\n**File 3: Local Override (`./grove.override.yml`)**\n\nThis file is typically ignored by version control (e.g., in `.gitignore`). It allows a developer to override settings for their local environment without affecting the project configuration. Here, we change the public port for the `api` service to avoid a conflict on the local machine.\n\n\nWhen `config.LoadDefault()` is called from within the project directory, the final merged configuration will effectively be:\n- `settings.mcp_port`: `1667` (from global)\n- `settings.project_name`: `my-web-app` (from project)\n- `services.api.image`: `my-api:1.2.0` (from project)\n- `services.api.ports`: `[\"9999:80\"]` (from override)",
      "example": "# ~/.config/grove/grove.yml\nsettings:\n  mcp_port: 1667 # Default MCP port for all projects\n# ./grove.yml\nversion: \"1.0\"\n\nsettings:\n  project_name: my-web-app\n\nservices:\n  api:\n    image: my-api:1.2.0\n    ports:\n      - \"8080:80\" # Default port for the API\n# ./grove.override.yml\nservices:\n  api:\n    ports:\n      - \"9999:80\" # Override the host port for local development"
    },
    {
      "name": "3. Managing Git Worktrees",
      "description": "The `git.WorktreeManager` provides a programmatic interface for managing Git worktrees. This is useful for automation that needs to operate on different branches in isolated directory trees without performing a full checkout.\n\nThis example shows how to create a worktree for a feature branch, list all worktrees, and then clean it up.",
      "example": "import (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"path/filepath\"\n\n    \"github.com/mattsolo1/grove-core/git\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    repoPath := \".\" // Assume current directory is a Git repository\n    worktreeDir := \"/tmp/my-feature-worktree\"\n    branchName := \"new-feature-branch\"\n\n    manager := git.NewWorktreeManager()\n\n    // 1. Create a new worktree and a new branch\n    fmt.Printf(\"Creating worktree at %s for branch %s...\\n\", worktreeDir, branchName)\n    err := manager.CreateWorktree(ctx, repoPath, worktreeDir, branchName, true)\n    if err != nil {\n        log.Fatalf(\"Failed to create worktree: %v\", err)\n    }\n    fmt.Println(\"Worktree created successfully.\")\n\n    // 2. List all worktrees for the repository\n    fmt.Println(\"\\nListing all worktrees:\")\n    worktrees, err := manager.ListWorktrees(ctx, repoPath)\n    if err != nil {\n        log.Fatalf(\"Failed to list worktrees: %v\", err)\n    }\n    for _, wt := range worktrees {\n        fmt.Printf(\"- Path: %s, Branch: %s, Commit: %s\\n\",\n            filepath.Base(wt.Path), wt.Branch, wt.Commit[:7])\n    }\n\n    // 3. Remove the worktree when done\n    fmt.Printf(\"\\nRemoving worktree at %s...\\n\", worktreeDir)\n    if err := manager.RemoveWorktree(ctx, repoPath, worktreeDir); err != nil {\n        log.Fatalf(\"Failed to remove worktree: %v\", err)\n    }\n    fmt.Println(\"Worktree removed successfully.\")\n}"
    },
    {
      "name": "4. Distinguishing Pretty and Structured Logging",
      "description": "The `logging` package provides two distinct logging mechanisms for different purposes:\n\n-   **`logging.NewLogger`**: Creates a structured logger (`logrus`) for internal application logging. These logs are intended for diagnostics, debugging, and machine parsing. They write to `stderr` and optionally to a file, and their format is controlled by `grove.yml`.\n-   **`logging.PrettyLogger`**: Creates a logger for generating styled, user-facing output directly to the console (`stderr`). This is used for providing clear feedback to the user, such as success or failure messages. Its output is not structured and is not sent to the log file.",
      "example": "import (\n    \"errors\"\n    \"github.com/mattsolo1/grove-core/logging\"\n)\n\nfunc main() {\n    // Structured logger for internal diagnostics\n    structuredLog := logging.NewLogger(\"file-processor\")\n\n    // Pretty logger for user-facing status messages\n    prettyLog := logging.NewPrettyLogger()\n\n    filePath := \"/path/to/important.doc\"\n\n    // Use the structured logger to record what the application is doing.\n    // This goes to stderr and the configured log file.\n    structuredLog.WithField(\"file\", filePath).Info(\"Starting to process file\")\n\n    // Use the pretty logger to inform the user about the result.\n    // This only goes to the console (stderr).\n    err := processFile(filePath)\n    if err != nil {\n        prettyLog.ErrorPretty(\"Failed to process file\", err)\n        structuredLog.WithError(err).Error(\"File processing failed\")\n    } else {\n        prettyLog.Success(\"Successfully processed file!\")\n        prettyLog.Path(\"Output saved to\", \"/path/to/output.txt\")\n        structuredLog.Info(\"File processing completed successfully\")\n    }\n}\n\nfunc processFile(path string) error {\n    // Simulate an error\n    return errors.New(\"permission denied\")\n}"
    },
    {
      "name": "5. Custom Error Handling",
      "description": "The `errors` package provides a set of structured error types that can be recognized and handled by the `cli.ErrorHandler`. This allows you to return specific, typed errors from your application logic and have them automatically translated into user-friendly messages at the CLI layer.\n\n**Step 1: Return a specific `GroveError` from your function**\n\nUse one of the error constructors from the `errors` package, like `ServiceNotFound`.\n\n\n**Step 2: Use the `cli.ErrorHandler` in your command**\n\nIn your `main.go`, instantiate an `ErrorHandler` and use it to handle errors returned from your command's execution.\n\n\nIf you run this command with a non-existent service name (e.g., `./my-tool start api`), the `ErrorHandler` will catch the `ErrCodeServiceNotFound` error and print a helpful, formatted message to the user:",
      "example": "import \"github.com/mattsolo1/grove-core/errors\"\n\n// findService simulates looking for a service in the configuration.\nfunc findService(name string, availableServices map[string]bool) error {\n    if !availableServices[name] {\n        // Return a specific, structured error.\n        return errors.ServiceNotFound(name)\n    }\n    return nil\n}\nimport (\n    \"os\"\n    \"github.com/mattsolo1/grove-core/cli\"\n    \"github.com/spf13/cobra\"\n)\n\nfunc main() {\n    rootCmd := cli.NewStandardCommand(\"start\", \"Starts a service\")\n\n    rootCmd.RunE = func(cmd *cobra.Command, args []string) error {\n        if len(args) == 0 {\n            // ...\n        }\n        serviceName := args[0]\n\n        // Get options to check for the --verbose flag\n        opts := cli.GetOptions(cmd)\n        \n        // This is where the error from findService would be returned\n        err := findService(serviceName, map[string]bool{\"db\": true})\n        if err != nil {\n            // The handler will inspect the error and print a friendly message.\n            handler := cli.NewErrorHandler(opts.Verbose)\n            return handler.Handle(err)\n        }\n\n        return nil\n    }\n\n    if err := rootCmd.Execute(); err != nil {\n        os.Exit(1)\n    }\n}\n$ ./my-tool start api\n‚ùå Service 'api' not found in grove.yml\nRun 'grove services' to see available services."
    }
  ],
  "best_practices": [
    {
      "title": "Logging",
      "text": "The `logging` package is designed for structured, machine-readable logs. To get the most out of it, you should favor structured fields over simple string formatting.\n\n### Use Structured Fields\n\nAlways prefer using `WithField` or `WithFields` to add context to your log messages. This makes logs easier to parse, filter, and analyze.\n\n**Recommended:**\n\n**Avoid:**\n\n### Use `WithError` for Errors\n\nWhen logging an error, use the `WithError` method. This attaches the full error to the log entry under a dedicated `error` key, preserving its context and stack trace if available.\n\n**Recommended:**\n\n**Avoid:**\n\nimport \"github.comcom/mattsolo1/grove-core/logging\"\n\nlog := logging.NewLogger(\"file-processor\")\n\n// Use structured fields to add context\nlog.WithField(\"file_path\", \"/data/file.txt\").Info(\"Processing file\")\n\n// Avoid string formatting, as it loses the structured context\nlog.Infof(\"Processing file %s\", \"/data/file.txt\")\n\nif err != nil {\n    log.WithError(err).Error(\"Failed to process file\")\n}\n\nif err != nil {\n    // This loses the structured error information\n    log.Errorf(\"Failed to process file: %v\", err)\n}"
    },
    {
      "title": "Configuration",
      "text": "The `config` package is designed to handle declarative configuration. Your `grove.yml` file should describe the desired state of your application, not the procedural steps to get there.\n\n### Keep `grove.yml` Declarative\n\nThe configuration file should define *what* your services and settings are. Logic for how to use these settings belongs in your Go code. This separation of concerns makes the configuration easier to understand and manage.\n\n### Use Environment Variables for Secrets\n\nSensitive information such as API keys, passwords, or tokens should not be stored directly in `grove.yml`. Instead, use environment variable expansion. The `config` loader will automatically substitute `${VAR_NAME}` or `${VAR_NAME:-default}` with the corresponding environment variable at load time.\n\n**Example `grove.yml`:**\n\nYou can then run your tool with the secrets provided in the environment:\n\nservices:\n  api:\n    image: my-api:latest\n    environment:\n      - DATABASE_URL=postgres://${DB_USER}:${DB_PASSWORD}@db:5432/mydb\n      - API_KEY=${SERVICE_API_KEY}\n\nDB_PASSWORD=mysecretpassword SERVICE_API_KEY=key123 my-tool up"
    },
    {
      "title": "Error Handling",
      "text": "The `errors` package provides a system for structured errors that integrate with the `cli.ErrorHandler`. This pattern separates error creation from error presentation.\n\n### Return `GroveError` Types\n\nFrom your application logic, return specific `GroveError` types using the provided constructors (e.g., `errors.ServiceNotFound`, `errors.ConfigInvalid`). This allows the CLI layer to catch these specific error codes and display helpful, user-friendly messages.\n\n**Example:**\n\nThe `cli.ErrorHandler` in your command's entry point will then translate this error into a clear message for the user, as it recognizes the `ErrCodeServiceNotFound` code.\n\npackage myapp\n\nimport \"github.com/mattsolo1/grove-core/errors\"\n\n// This function's logic is only concerned with its domain, not\n// with how errors are presented to the user.\nfunc FindService(name string, cfg *MyConfig) error {\n    if _, ok := cfg.Services[name]; !ok {\n        // Return a structured, typed error.\n        return errors.ServiceNotFound(name)\n    }\n    return nil\n}"
    },
    {
      "title": "Extensibility",
      "text": "When building a new tool that integrates with the Grove ecosystem, it is best to create a custom configuration extension within `grove.yml` rather than using a separate configuration file.\n\n### Design a Custom Configuration Extension\n\nDefine a Go struct for your tool's configuration and a corresponding top-level key in `grove.yml`. Use `config.UnmarshalExtension` to load your settings in a type-safe manner. This keeps all project configuration in a single, predictable location (`grove.yml`).\n\n**Example:**\n\n**`grove.yml`:**\n\n**Go Code:**\n\nversion: \"1.0\"\nservices:\n  # ...\n\n# Custom section for a new tool called \"grove-flow\"\nflow:\n  default_model: \"claude-3-opus\"\n  max_retries: 3\n\nimport \"github.com/mattsolo1/grove-core/config\"\n\ntype FlowConfig struct {\n    DefaultModel string `yaml:\"default_model\"`\n    MaxRetries   int    `yaml:\"max_retries\"`\n}\n\nfunc loadFlowConfig() (*FlowConfig, error) {\n    coreCfg, err := config.LoadDefault()\n    if err != nil {\n        return nil, err\n    }\n\n    var flowCfg FlowConfig\n    if err := coreCfg.UnmarshalExtension(\"flow\", \u0026flowCfg); err != nil {\n        return nil, err\n    }\n\n    return \u0026flowCfg, nil\n}"
    },
    {
      "title": "CLI Design",
      "text": "To ensure a consistent user experience across all tools in the Grove ecosystem, always use the helpers provided by the `cli` package.\n\n### Use `NewStandardCommand`\n\nAlways initialize your root command and subcommands with `cli.NewStandardCommand`. This function automatically adds a standard set of persistent flags (`--verbose`, `--json`, `--config`) to your command, ensuring that all Grove tools share a common and predictable interface.\n\n**Example:**\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/mattsolo1/grove-core/cli\"\n)\n\nfunc main() {\n\trootCmd := cli.NewStandardCommand(\n\t\t\"my-tool\",\n\t\t\"A brief description of my tool.\",\n\t)\n\n\t// Add subcommands and logic here...\n\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}"
    }
  ]
}